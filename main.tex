\documentclass[a4paper]{article}
\usepackage{student}

% PREENCHA ESSA PARTE COM SEUS DADOS

\setuniversity{UNIVERSIDADE DO ESTADO DE SANTA CATARINA}
\setdepartment{CENTRO DE EDUCAÇÃO DO PLANALTO NORTE/DEPARTAMENTO DE SISTEMAS DE INFORMAÇÃO}
\setmodule{ROTEIRO DE ATIVIDADES ESP-32 e IoT}
\setterm{2025/5° FASE}

\title{AUTOMAÇÃO DE SISTEMAS}
\setmembername{LISTA DE NOMES DOS ALUNOS}
\setmemberuid{LISTA DE MATRÍCULAS DOS ALUNOS}

\usepackage{amsmath,amssymb,bm}
\usepackage{hyperref}
\usepackage[T1]{fontenc}


\begin{document}

    \header{}
    % UTILIZAR O AMBIENTE "answer" para criar uma nova caixa de resposta
    % O texto entre chaves [] será utilizado como título antes da caixa
    % Exemplo abaixo:
    
    \begin{answer}[1. Introdução ao ESP32 e Conceitos de IoT]
    \begin{enumerate}
        \item O que é o microcontrolador?
         
            Um microcontrolador é um circuito integrado que contém um processador, 
            memória e periféricos de entrada/saída em um único chip, sendo utilizado
            para controlar dispositivos eletrônicos de forma autônoma.

        \item Diferença entre ESP8266, ESP32 e Arduino Uno.
        
            O ESP8266 é um microcontrolador com conectividade Wi-Fi, enquanto o ESP32
            é uma versão mais avançada com Wi-Fi e Bluetooth integrados, oferecendo
            mais recursos e potência de processamento. O Arduino Uno é uma placa
            de prototipagem baseada no microcontrolador ATmega328, que não possui
            conectividade Wi-Fi ou Bluetooth nativa, mas é amplamente utilizado
            para projetos de eletrônica e programação básica.

        \item Conceitos básicos de Internet das Coisas (IoT).
        
            Internet das Coisas (IoT) refere-se à interconexão de dispositivos físicos
            à internet, permitindo que eles coletem e compartilhem dados, além de
            serem controlados remotamente. Isso possibilita a automação, monitoramento
            e otimização de processos em diversas áreas, como residências, indústrias
            e cidades inteligentes.
        
        \item Exemplos de aplicações com ESP32 e IoT.
            O ESP32 pode ser utilizado em diversas aplicações de IoT, como:

            \begin{itemize}
                \item Monitoramento ambiental (temperatura, umidade, qualidade do ar);
                \item Automação residencial (controle de luzes, eletrodomésticos, sistemas de segurança);
                \item Sistemas de irrigação inteligente;
                \item Dispositivos vestíveis (wearables) para monitoramento de saúde;
                \item Controle remoto de robôs e drones.
            \end{itemize}
    \end{enumerate}
    \end{answer}
    
    \begin{answer}[2. Instalação da IDE Arduino e Configuração do ESP32.]
        \begin{enumerate}
            \item  Instalação da IDE Arduino:

                A IDE Arduino é uma plataforma de desenvolvimento integrada que permite
                programar microcontroladores, incluindo o ESP32. Para instalar a IDE,
                basta baixar o instalador do site oficial do Arduino e seguir as instruções
                de instalação.

                \begin{itemize}
                    \item  Acesse o site oficial do Arduino: \url{https://www.arduino.cc/en/software}.
                    \item  Baixe a versão adequada para o seu sistema operacional (Windows, macOS, Linux).
                    \item  Execute o instalador e siga as instruções na tela.
                    \item  Após a instalação, abra a IDE Arduino.
                \end{itemize}
            \item Configuração do ESP32 na IDE Arduino:
            
                Para programar o ESP32 na IDE Arduino, é necessário instalar o suporte
                ao ESP32. Siga os passos abaixo:

                \begin{itemize}
                    \item  Abra a IDE Arduino.
                    \item  Vá para "File" $>$ "Preferences".
                    \item  Na seção "Additional Boards Manager URLs", adicione a seguinte  URL:
                        \url{https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json}.
                    \item  Para facilitar, veja a imagem abaixo mostrando onde adicionar a URL:

                        \begin{center}
                            \includegraphics[width=0.7\textwidth]{images/addURL}
                        \end{center}
                    \item  Clique em "OK" para salvar as preferências.
                    \item  Vá para "Tools" $>$ "Board" $>$ "Boards Manager".
                    \item  Pesquise por "ESP32" e instale o pacote "esp32 by Espressif".
                    \item  Veja a imagem abaixo mostrando a seleção da placa:

                        \begin{center}
                            \includegraphics[width=0.7\textwidth]{images/Esp-32-board-install.png}
                        \end{center}
                    \item  Após a instalação, selecione a sua placa ESP32 em "Tools" $>$ "Board".
                    \item  Após instalar o pacote e selecionr a placa, conecte sua placa ESP32 ao computador.
                    \item  Selecione a porta correta em "Tools" $>$ "Port".
                    
                \end{itemize}
            \item  Teste de conexão com código "Blink":

                Para verificar se a configuração está correta, você pode carregar o
                exemplo "Blink" na IDE Arduino. Siga os passos abaixo:

                \begin{itemize}
                    \item  Vá para "File" $>$ "Examples" $>$ "01.Basics" $>$ "Blink".
                    \item  O código do exemplo deve ser semelhante ao seguinte:

                    \begin{verbatim}
                    void setup() {
                        pinMode(LED_BUILTIN, OUTPUT);
                    }

                    void loop() {
                        digitalWrite(LED_BUILTIN, HIGH); // Liga LED
                        delay(1000); // Espera por 1 segundo
                        digitalWrite(LED_BUILTIN, LOW); // Desliga LED
                        delay(1000); // Espera por 1 segundo
                    }
                    \end{verbatim}

                    \item  Carregue o código na placa ESP32 clicando no botão de upload (seta para a direita).
                    \begin{center}
                        \includegraphics[width=0.7\textwidth]{images/upload.png}
                    \end{center}
                    \item  Após o upload, o LED integrado da placa deve piscar a cada segundo.
                \end{itemize}
        \end{enumerate}
    \end{answer}

    \begin{answer}[3. Comparação com ESP8266 e Arduino Uno.]
        \begin{itemize}
            \item \textbf{ESP32:} Microcontrolador avançado da Espressif, possui processador dual-core, conectividade Wi-Fi e Bluetooth integrados, maior quantidade de pinos de entrada/saída, suporte a múltiplos periféricos, ADCs de maior resolução e maior capacidade de processamento e memória. Ideal para aplicações IoT mais complexas e que exigem conectividade sem fio diversificada.
                \begin{center}
                    \includegraphics[width=0.5\textwidth]{images/esp32.png}
                \end{center}
            \item \textbf{ESP8266:} Também da Espressif, é mais simples que o ESP32, com processador single-core, conectividade Wi-Fi integrada, menos pinos e recursos. É indicado para projetos IoT básicos que demandam apenas Wi-Fi e menor consumo de recursos.
                \begin{center}
                    \includegraphics[width=0.5\textwidth]{images/esp8266.png}
                \end{center}
            \item \textbf{Arduino Uno:} Baseado no microcontrolador ATmega328P, não possui conectividade Wi-Fi ou Bluetooth nativa, mas é muito utilizado em projetos de eletrônica básica, prototipagem e ensino. Possui menos memória e processamento em relação aos ESPs, mas conta com vasta documentação e comunidade.
                \begin{center}
                    \includegraphics[width=0.5\textwidth]{images/arduino_uno.png}
                \end{center}
        \end{itemize}

        \textbf{Resumo:} O ESP32 é o mais completo em termos de recursos e conectividade, seguido pelo ESP8266 (mais simples e barato), enquanto o Arduino Uno é ideal para projetos básicos sem necessidade de conexão sem fio.
    \end{answer}

    \begin{answer}[4. Leitura de sensores analógicos e digitais]

        Obetivo: Aprender a ler dados de sensores analógicos e digitais utilizando o ESP32.
        \begin{enumerate}
            \item Leitura de sensores analógicos:

                Para ler dados de sensores analógicos, como um potenciômetro ou sensor de temperatura, você pode usar a função `analogRead()`. O ESP32 possui vários pinos ADC (Conversores Analógico-Digital) que podem ser utilizados para essa finalidade.

                Exemplo de código para ler um sensor analógico:

            \begin{verbatim}
            int sensorPin = 34; // Pino ADC
            int sensorValue = 0;

            void setup() {
                Serial.begin(115200);
            }

            void loop() {
                sensorValue = analogRead(sensorPin); // Lê o valor do sensor
                Serial.println(sensorValue); // Imprime o valor no monitor serial
                delay(1000); // Espera 1 segundo
            }
            \end{verbatim}

            \item Leitura de sensores digitais:

                Para ler dados de sensores digitais, como um botão ou sensor de movimento, você pode usar a função `digitalRead()`. O ESP32 possui vários pinos digitais que podem ser utilizados para essa finalidade.

                Exemplo de código para ler um sensor digital:

            \begin{verbatim}
            int buttonPin = 2; // Pino digital
            int buttonState = 0;

            void setup() {
                pinMode(buttonPin, INPUT); // Configura o pino como entrada
                Serial.begin(115200);
            }

            void loop() {
                buttonState = digitalRead(buttonPin); // Lê o estado do botão
                Serial.println(buttonState); // Imprime o estado no monitor serial
                delay(1000); // Espera 1 segundo
            }
            \end{verbatim}
        \end{enumerate}
    \end{answer}

    \begin{answer}[5. Controle de atuadores (EX: LED e buzzer).]
        \begin{enumerate}
            \item Controle de LED:

                Para controlar um LED, você pode usar a função `digitalWrite()`. O ESP32 possui vários pinos digitais que podem ser utilizados para essa finalidade.

                Exemplo de código para controlar um LED:

            \begin{verbatim}
            int ledPin = 2; // Pino do LED

            void setup() {
                pinMode(ledPin, OUTPUT); // Configura o pino como saída
            }

            void loop() {
                digitalWrite(ledPin, HIGH); // Liga o LED
                delay(1000); // Espera 1 segundo
                digitalWrite(ledPin, LOW); // Desliga o LED
                delay(1000); // Espera 1 segundo
            }
            \end{verbatim}
            O resultado será um LED piscando a cada segundo (Conforme a imagem abaixo).
            \begin{center}
                \includegraphics[width=0.5\textwidth]{images/led.png}
            \end{center}
            \begin{center}
                \small
                \textbf{Figura:} Imagem retirada do simulador ESP32 \href{https://wokwi.com}{wokwi.com}.
            \end{center}

            \item Controle de buzzer:

                Para controlar um buzzer, você também pode usar a função `digitalWrite()`.

                Exemplo de código para controlar um buzzer:

            \begin{verbatim}
            int buzzerPin = 2; // Pino do buzzer

            void setup() {
                pinMode(buzzerPin, OUTPUT); // Configura o pino como saída
            }

            void loop() {
                // Aumenta a frequência gradualmente (efeito de sirene)
                for (int freq = 800; freq <= 2000; freq += 10) {
                    tone(buzzerPin, freq); // Gera tom com a frequência atual
                    delay(10); // Pequeno atraso para suavizar a transição
                }
                
                // Diminui a frequência gradualmente
                for (int freq = 2000; freq >= 800; freq -= 10) {
                    tone(buzzerPin, freq); // Gera tom com a frequência atual
                    delay(10); // Pequeno atraso para suavizar a transição
                }
                
                noTone(buzzerPin); // Para o som
                delay(200); // Pausa breve antes de reiniciar
                }
            \end{verbatim}
            O resultado será um buzzer emitindo um som de sirene (visualmente conforme a imagem abaixo).
            \begin{center}
                \includegraphics[width=0.5\textwidth]{images/buzzer.png}
            \end{center}
            \begin{center}
                \small
                \textbf{Figura:} Imagem retirada do simulador ESP32 \href{https://wokwi.com}{wokwi.com}.
            \end{center}
        \end{enumerate}
    \end{answer}

    \begin{answer}[6. Conectando o ESP32 a uma rede Wi-Fi.]
        \begin{enumerate}
            \item Biblioteca WiFi\.h:
            
            Para conectar o ESP32 a uma rede Wi-Fi, utilizamos a biblioteca WiFi.h, que já vem incluída no pacote ESP32 da IDE Arduino. Esta biblioteca fornece todas as funções necessárias para gerenciar conexões Wi-Fi..

            \begin{verbatim}
            #include <WiFi.h>
            \end{verbatim}

            \item Configuração básica de conexão Wi-Fi:

                Exemplo básico de como conectar o ESP32 a uma rede Wi-Fi fornecendo o SSID e senha:

            \begin{verbatim}
            #include <WiFi.h>

            const char* ssid = "NOME_DA_SUA_REDE";
            const char* password = "SENHA_DA_SUA_REDE";

            void setup() {
                Serial.begin(115200);

                WiFi.begin(ssid, password);
                Serial.print("Conectando à rede Wi-Fi");

                while (WiFi.status() != WL_CONNECTED) {
                    delay(1000);
                    Serial.print(".");
                }

                Serial.println();
                Serial.println("Conectado com sucesso!");
                Serial.print("Endereço IP: ");
                Serial.println(WiFi.localIP());
            }

            void loop() {
            // Código principal aqui
            }

            \end{verbatim}
        
            \item Verificação do status da conexão:

                Código para verificar o status da conexão e exibir informações sobre a rede Wi-Fi:
            \begin{verbatim}
                #include <WiFi.h>

                const char* ssid = "NOME_DA_SUA_REDE";
                const char* password = "SENHA_DA_SUA_REDE";

                void setup() {
                Serial.begin(115200);

                WiFi.begin(ssid, password);
                Serial.print("Conectando à rede Wi-Fi");

                int tentativas = 0;
                while (WiFi.status() != WL_CONNECTED && tentativas < 20) {
                    delay(1000);
                    Serial.print(".");
                    tentativas++;
                }

                if (WiFi.status() == WL_CONNECTED) {
                    Serial.println();
                    Serial.println("Conectado com sucesso!");
                    Serial.print("SSID: ");
                    Serial.println(WiFi.SSID());
                    Serial.print("Endereço IP: ");
                    Serial.println(WiFi.localIP());
                    Serial.print("Intensidade do sinal (RSSI): ");
                    Serial.println(WiFi.RSSI());
                } else {
                    Serial.println();
                    Serial.println("Falha na conexão Wi-Fi!");
                    Serial.println("Verifique as credenciais da rede.");
                }
                }

                void loop() {
                if (WiFi.status() == WL_CONNECTED) {
                    Serial.println("Wi-Fi conectado");
                } else {
                    Serial.println("Wi-Fi desconectado - tentando reconectar...");
                    WiFi.begin(ssid, password);
                }

                delay(10000);
                }
            \end{verbatim}
        
            \item Códigos de status Wi-Fi:

                Principais códigos de status retornados por WiFi.status():
                    \begin{itemize}
                        \item \texttt{WL\_CONNECTED} (3): Conectado com sucesso.
                        \item \texttt{WL\_NO\_SSID\_AVAIL} (1): SSID não encontrado.
                        \item \texttt{WL\_CONNECT\_FAILED}: (4) Falha na conexão por senha incorreta.   
                        \item \texttt{WL\_CONNECTION\_LOST}: A conexão com a rede Wi-Fi foi perdida.
                        \item \texttt{WL\_DISCONNECTED}: O ESP32 está desconectado da rede Wi-Fi.
                    \end{itemize}
            
            \item Exemplo completo com reconexão automática:

                Código completo com reconexão automática à rede Wi-Fi:
            \begin{verbatim}
                #include <WiFi.h>

                const char* ssid = "NOME_DA_SUA_REDE";
                const char* password = "SENHA_DA_SUA_REDE";

                void conectarWiFi() {
                WiFi.begin(ssid, password);

                Serial.print("Conectando à rede Wi-Fi");

                int tentativas = 0;
                while (WiFi.status() != WL_CONNECTED && tentativas < 20) {
                    delay(1000);
                    Serial.print(".");
                    tentativas++;
                }

                if (WiFi.status() == WL_CONNECTED) {
                    Serial.println();
                    Serial.println("OK Conectado com sucesso!");
                    exibirInformacoesRede();
                } else {
                    Serial.println();
                    Serial.println("X Falha na conexão Wi-Fi!");
                }
                }

                void exibirInformacoesRede() {
                    Serial.println("=== Informações da Rede ===");
                    Serial.print("SSID: ");
                    Serial.println(WiFi.SSID());
                    Serial.print("Endereço IP: ");
                    Serial.println(WiFi.localIP());
                    Serial.print("Gateway: ");
                    Serial.println(WiFi.gatewayIP());
                    Serial.print("Máscara de sub-rede: ");
                    Serial.println(WiFi.subnetMask());
                    Serial.print("DNS: ");
                    Serial.println(WiFi.dnsIP());
                    Serial.print("Intensidade do sinal (RSSI): ");
                    Serial.print(WiFi.RSSI());
                    Serial.println(" dBm");
                    Serial.println("===========================");
                }

                void setup() {
                    Serial.begin(115200);
                    WiFi.mode(WIFI_STA);
                    conectarWiFi();
                }

                void loop() {
                if (WiFi.status() != WL_CONNECTED) {
                    Serial.println("Conexão Wi-Fi perdida. Tentando reconectar...");
                    conectarWiFi();
                } else {
                    Serial.println("Wi-Fi conectado - Sistema funcionando normalmente");
                }

                delay(30000);
                }
            \end{verbatim}
        
            \item Explicação do código:

                Dicas importantes:
                \begin{itemize}
                        \item \texttt Substitua as credenciais da rede pelos seus dados reais.
                        \item \texttt RSSI próximo de 0 indica sinal forte. Mais negativo = mais fraco.
                        \item \texttt{WiFi.mode(WIFI\_STA)} configura o ESP32 como cliente Wi-Fi.
                        \item Outros modos: \texttt{WIFI\_AP} (Access Point), \texttt{WIFI\_AP\_STA} (modo misto).
                        \item \texttt Definir limite de tentativas evita travamento se a rede estiver indisponível.
                    \end{itemize}

            \item Testando a conexão:
            
                \begin{itemize}
                    \item \texttt Após carregar o código, abra o Monitor Serial (Ctrl+Shift+M).
                    \item \texttt Configure para 115200 baud.
                    \item \texttt Veja as mensagens de conexão e o IP atribuído ao ESP32.
                \end{itemize}

            Com o ESP32 conectado, é possível comunicar com outros dispositivos e com a Internet usando protocolos como MQTT.
        \end{enumerate}
    \end{answer}

    \begin{answer}[7. Introdução ao protocolo MQTT.]
        O protocolo MQTT é o protocolo padrão pra comunicação entre dispositivos IoT. Ele é
        planejado pra ser extremamente leve, com o padrão de publicador / assinante que é ideal pra
        conectar dispositivos com o mínimo de recursos possível. Ele é usado em diversas indústrias,
        como automotiva, manufatura, telecomunicação, entre outras.

        \begin{enumerate}
            \item O padrão da indústria:
            
                Ele é o protocolo mais usado na indústria, porque é o que melhor funciona em dispositivos com
                recursos limitados, com baixa largura de banda e conectividade limitada. Ele usa por baixo dos
                panos o TCP/IP, com um formato de mensagem binária, em contraste com outros protocolos
                que usam um formato de mensagens de texto, como o HTTP, saindo na frente no transporte de
                dados.
            
            \item Modelo Publicador / Assinante:
            \begin{itemize}
                    \item \texttt Publicadores (publishers) enviam mensagens em tópicos.
                    \item \texttt Assinantes (subscribers) recebem mensagens do tópico que assinaram.
                    \item \texttt Um broker (servidor intermediário) gerencia o envio das mensagens aos clientes.
                \end{itemize}
            
            É assim que funciona a comunicação entre os dispositivos com o protocolo MQTT. Ele também
            tem outras funcionalidades interessantes, como a de sessões persistentes: se a sessão entre
            um publicador / assinante for desconectada, a sessão vai continuar ativa mesmo assim. Uma
            vez que a internet for conectada novamente, eles vão se conectar de novo automaticamente e
            continuar a sessão.

            Também existem outras opções que o MQTT oferece:

            \begin{itemize}
                    \item \texttt {Retenção de mensagens:}  É possível configurar mensagens como "retidas", assim quando novos assinantes assinam um tópico, eles recebem imediatamente a última mensagem publicada.
                    \item \texttt {Qualidade de serviço (QoS):}Oferece três níveis de entrega de mensagens:
                        \begin{itemize}
                            \item QoS 0: Entrega no mínimo uma vez (sem garantia de entrega).
                            \item QoS 1: Entrega pelo menos uma vez (pode haver duplicação).
                            \item QoS 2: Entrega exatamente uma vez (garantia de entrega sem duplicação).
                        \end{itemize}
                    \item \texttt {Mensagens com última vontade (Last will and testament):} Permite que o cliente defina uma mensagem que será enviada se ele se desconectar de forma inesperada. É útil pra detectar falhas em dispositivos.
                \end{itemize}

        \end{enumerate}

    \end{answer}

    \begin{answer}[8. Publicando dados do sensor em um broker MQTT.]
        Quisque eget velit eget arcu rhoncus dictum non quis turpis. Nulla fermentum nulla nec vestibulum lacinia. Sed aliquam euismod dolor a efficitur. Fusce a nisi at justo vulputate tempor sed id lectus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Duis imperdiet ut dolor at varius. Pellentesque mattis turpis diam, et maximus orci aliquet id. Sed luctus a magna ac mattis. Sed ultricies quis turpis nec consequat. Donec a placerat metus, a tempor nulla. Maecenas gravida, diam sed aliquet efficitur, magna risus pulvinar orci, vel rutrum velit metus et tortor. Nam maximus, nulla eu semper scelerisque, mi sem vulputate tellus, nec hendrerit nulla ligula vel libero. Maecenas convallis pellentesque massa a ornare.

        Nam rhoncus magna sit amet porttitor condimentum. Vestibulum rhoncus consectetur est nec volutpat. Mauris volutpat nisi at tortor auctor, id ornare eros tempus. Aliquam et sapien mattis, eleifend turpis et, bibendum ipsum. Quisque vel semper risus, nec aliquam dolor. Maecenas non semper risus, sagittis eleifend nunc. Cras turpis elit, vulputate in porttitor at, rutrum eget justo. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Cras quis placerat tellus, eget gravida nunc. Integer malesuada vitae tortor non sollicitudin. Suspendisse eu sem purus.
    \end{answer}

    \begin{answer}[9. Recebendo comandos MQTT para controle de atuadores.]
        Quisque eget velit eget arcu rhoncus dictum non quis turpis. Nulla fermentum nulla nec vestibulum lacinia. Sed aliquam euismod dolor a efficitur. Fusce a nisi at justo vulputate tempor sed id lectus. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Duis imperdiet ut dolor at varius. Pellentesque mattis turpis diam, et maximus orci aliquet id. Sed luctus a magna ac mattis. Sed ultricies quis turpis nec consequat. Donec a placerat metus, a tempor nulla. Maecenas gravida, diam sed aliquet efficitur, magna risus pulvinar orci, vel rutrum velit metus et tortor. Nam maximus, nulla eu semper scelerisque, mi sem vulputate tellus, nec hendrerit nulla ligula vel libero. Maecenas convallis pellentesque massa a ornare.

        Nam rhoncus magna sit amet porttitor condimentum. Vestibulum rhoncus consectetur est nec volutpat. Mauris volutpat nisi at tortor auctor, id ornare eros tempus. Aliquam et sapien mattis, eleifend turpis et, bibendum ipsum. Quisque vel semper risus, nec aliquam dolor. Maecenas non semper risus, sagittis eleifend nunc. Cras turpis elit, vulputate in porttitor at, rutrum eget justo. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Cras quis placerat tellus, eget gravida nunc. Integer malesuada vitae tortor non sollicitudin. Suspendisse eu sem purus.
    \end{answer}

\end{document}
